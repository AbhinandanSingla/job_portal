var testElem = document.createElement('test'),
    docElement = document.documentElement,
    defaultView = document.defaultView,
    getComputedStyle = defaultView && defaultView.getComputedStyle,
    computedValueBug,
    runit = /^(-?[\d+\.\-]+)([a-z]+|%)$/i,
    convert = {},
    conversions = [1 / 25.4, 1 / 2.54, 1 / 72, 1 / 6],
    units = ['mm', 'cm', 'pt', 'pc', 'in', 'mozmm'],
    i = 6;
docElement.appendChild(testElem);

if (getComputedStyle) {
  testElem.style.marginTop = '1%';
  computedValueBug = getComputedStyle(testElem).marginTop === '1%';
}

while (i--) {
  convert[units[i] + "toPx"] = conversions[i] ? conversions[i] * convert.inToPx : toPx(testElem, '1' + units[i]);
}

docElement.removeChild(testElem);
testElem = undefined;

function toPx(elem, value, prop, force) {
  prop = prop || 'width';
  var style,
      inlineValue,
      ret,
      unit = (value.match(runit) || [])[2],
      conversion = unit === 'px' ? 1 : convert[unit + 'toPx'],
      rem = /r?em/i;

  if (conversion || rem.test(unit) && !force) {
    elem = conversion ? elem : unit === 'rem' ? docElement : prop === 'fontSize' ? elem.parentNode || elem : elem;
    conversion = conversion || parseFloat(curCSS(elem, 'fontSize'));
    ret = parseFloat(value) * conversion;
  } else {
    style = elem.style;
    inlineValue = style[prop];

    try {
      style[prop] = value;
    } catch (e) {
      return 0;
    }

    ret = !style[prop] ? 0 : parseFloat(curCSS(elem, prop));
    style[prop] = inlineValue !== undefined ? inlineValue : null;
  }

  return ret;
}

function curCSS(elem, prop) {
  var value,
      pixel,
      unit,
      rvpos = /^top|bottom/,
      outerProp = ["paddingTop", "paddingBottom", "borderTop", "borderBottom"],
      innerHeight,
      parent,
      i = 4;

  if (getComputedStyle) {
    value = getComputedStyle(elem)[prop];
  } else if (pixel = elem.style['pixel' + prop.charAt(0).toUpperCase() + prop.slice(1)]) {
    value = pixel + 'px';
  } else if (prop === 'fontSize') {
    value = toPx(elem, '1em', 'left', 1) + 'px';
  } else {
    value = elem.currentStyle[prop];
  }

  unit = (value.match(runit) || [])[2];

  if (unit === '%' && computedValueBug) {
    if (rvpos.test(prop)) {
      innerHeight = (parent = elem.parentNode || elem).offsetHeight;

      while (i--) {
        innerHeight -= parseFloat(curCSS(parent, outerProp[i]));
      }

      value = parseFloat(value) / 100 * innerHeight + 'px';
    } else {
      value = toPx(elem, value);
    }
  } else if ((value === 'auto' || unit && unit !== 'px') && getComputedStyle) {
    value = 0;
  } else if (unit && unit !== 'px' && !getComputedStyle) {
    value = toPx(elem, value) + 'px';
  }

  return value;
}

export default toPx;